//-------------------DMA TESTING -----------------//
/******************************************************
实验内容： 设定DMA
当检测到按键S1时，设定DMA从RAM里转出数据，如果成功，则
点亮LED3并在c串口上提示 Correct， 否则提示 Error
******************************************************/

#define LED1 P1_0 // 定义P1.0口为LED1控制端
#define LED2 P1_1 // 定义P1.1口为LED2控制端
#define LED3 P1_4 // 定义P1.4口为LED3控制端

#define KEY1 P0_1 // P0.1口控制按键KEY1

#define HAL_DMA_U0DBUF 0x70C1 // 设置DMA目的地

#include "hal.h"
#include "hal_types.h"
#include <string.h>
char titleString[] = "-------- DMA Testing --------";
char hintString[] = "...Push KEY1 to start DMA ...";
char goodString[] = "...yes, DMA transfer correct";
char badString[] = "...bad,DMA transfer Error";
char revbuf; // 缓冲字符

DMA_DESC dmaChannel;

/****************************************************************************
 * 名    称: LedOnOrOff()
 * 功    能: 点亮或熄灭所有LED灯
 * 入口参数: mode为0时LED灯亮  mode为1时LED灯灭
 * 出口参数: 无
 ****************************************************************************/
void LedOnOrOff(uint8 mode)
{
    LED1 = mode;
    LED2 = mode;
    LED3 = mode;
}

/****************************************************************************
 * 名    称: InitLed()
 * 功    能: 设置LED相应的IO口
 * 入口参数: 无
 * 出口参数: 无
 ****************************************************************************/
void InitLed(void)
{

    P1DIR |= 0x01; // P1.0定义为输出口
    P1DIR |= 0x02; // P1.1定义为输出口
    P1DIR |= 0x10; // P1.4定义为输出口
    asm("NOP");

    LedOnOrOff(0); // 使所有LED灯默认为熄灭状态
}

/****************************************************************************
 * 名    称: InitKey()
 * 功    能: 设置按键相应的IO口
 * 入口参数: 无
 * 出口参数: 无
 ****************************************************************************/
void InitKey(void)
{

    P0SEL &= ~0x02; // 设置P0.1为普通IO口
    P0DIR &= ~0x02; // 按键接在P0.1口上，设P0.1为输入模式
    P0INP &= ~0x02; // 打开P0.1上拉电阻
}

/****************************************************************************
 * 名    称: KeyScan()
 * 功    能: 读取按键状态
 * 入口参数: 无
 * 出口参数: 0为抬起   1为按键按下
 ****************************************************************************/
unsigned char KeyScan(void)
{
    if (KEY1 == 0)
    {
        halWait(20);
        if (KEY1 == 0)
        {
            while (!KEY1)
                ;     // 松手检测
            return 1; // 有按键按下
        }
    }

    return 0; // 无按键按下
}

/****************************
//IO初始化程序
*****************************/
void Initial_IO(void)
{
    InitLed();
    InitKey();
}

void initDma(void);
/****************************************************************************
 * 名    称: InitUart()
 * 功    能: 串口初始化函数
 * 入口参数: 无
 * 出口参数: 无
 ****************************************************************************/
void InitUart(void)
{
    PERCFG = 0x00;  // 外设控制寄存器 USART 0的IO位置:0为P0口位置1
    P0SEL = 0x0c;   // P0_2,P0_3用作串口（外设功能）
    P2DIR &= ~0xC0; // P0优先作为UART0

    U0CSR |= 0x80; // 设置为UART方式
    U0GCR |= 11;   // baud_e
    U0BAUD |= 216; // 波特率设为115200
    UTX0IF = 0;    // UART0 TX中断标志初始置位0
    U0CSR |= 0x40; // 允许接收
    IEN0 |= 0x84;  // 开中断
}

/****************************************************************************
 * 名    称: UartSendString()
 * 功    能: 串口发送函数
 * 入口参数: Data:发送缓冲区   len:发送长度
 * 出口参数: 无
 ****************************************************************************/
void UartSendString(char *Data, int len)
{
    uint16 i;

    for (i = 0; i < len; i++)
    {
        U0DBUF = *Data++;
        while (UTX0IF == 0)
            ;
        UTX0IF = 0;
    }
    U0DBUF = 0x0d;
    while (UTX0IF == 0)
        ;
    UTX0IF = 0;
    U0DBUF = 0x0a;
    while (UTX0IF == 0)
        ;
    UTX0IF = 0;
    halWait(600);
}

/****************************************************************************
 * 名    称: UART0RX_ISR()
 * 功    能: 接收中断处理
 * 入口参数: 无
 * 出口参数: 无
 ****************************************************************************/
char RxBuf;
#pragma vector = URX0_VECTOR
__interrupt void UART0RX_ISR(void)
{
    revbuf = U0DBUF;
    DMA_SET_ADDR_DESC0(&dmaChannel);
    DMA_ABORT_CHANNEL(0);
    DMA_ARM_CHANNEL(0);
    DMAIRQ = 0x00;
    DMA_START_CHANNEL(0);
    URX0IF = 0;
}

/******************************************************************************
 * @fn  initDma
 *
 * @brief
 *      Initializes components for the DMA transfer application example.
 ******************************************************************************/
void initDma(void)
{
    SET_MAIN_CLOCK_SOURCE(CRYSTAL);

    Initial_IO();
    InitUart(); // 调用串口初始化函数

    UartSendString(&titleString[0], sizeof(titleString)); // 显示Title字符串
}

/******************************************************************************
 * @fn  dma_main
 *
 * @brief
 *      Sets up the DMA to transfer data between to RAM locations, trigged by
 *      external interrupt generated by button S1. Checks validity of data
 *      after transfer.
 ******************************************************************************/
void main(void)
{

    initDma();

    // Clearing the destination
    // memset(destString, 0, sizeof(destString));
    // Setting up the DMA channel.
    SET_WORD(dmaChannel.SRCADDRH, dmaChannel.SRCADDRL, &revbuf);          // The start address of the data to be transmitted
    SET_WORD(dmaChannel.DESTADDRH, dmaChannel.DESTADDRL, HAL_DMA_U0DBUF); // The start address of the destination.
    SET_WORD(dmaChannel.LENH, dmaChannel.LENL, sizeof(revbuf));           // Setting the number of bytes to transfer.
    dmaChannel.VLEN = VLEN_USE_LEN;                                       // Using the length field to determine how many bytes to transfer.
    dmaChannel.PRIORITY = PRI_HIGH;                                       // High priority.
    dmaChannel.M8 = M8_USE_8_BITS;                                        // Irrelevant since length is determined by the LENH and LENL.
    dmaChannel.IRQMASK = FALSE;                                           // The DMA shall not issue an IRQ upon completion.
    dmaChannel.DESTINC = DESTINC_0;                                       // The destination address is to be incremented by 1 after each transfer.
    dmaChannel.SRCINC = SRCINC_1;                                         // The source address inremented by 1 byte after each transfer.
    dmaChannel.TRIG = DMATRIG_URX0;                                       // URX0 接受后触发中断
    dmaChannel.TMODE = TMODE_BLOCK;                                       // The number of bytes specified by LENH and LENL is transferred.
    dmaChannel.WORDSIZE = WORDSIZE_BYTE;                                  // One byte is transferred each time.
    asm("nop");
    while (1)
    {
        while(!(DMAIRQ & DMA_CHANNEL_0)); //等待传输完毕标志置位
    }
}
